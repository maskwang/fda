var JsCrypt = require('./core').JsCrypt;
require('./enc-base64');
require('./md5');
require('./evpkdf');
require('./cipher-core');
require('./aes');

//settings
var settings = require('../../cfg/settings').jscrypt;

var JsonFormatter = require('./jsonformatter').JsonFormatter;

exports.JsCrypt = JsCrypt;
exports.JsonFormatter = JsonFormatter;

//token requesting
//manual setting
module.exports.setSettings = function (stgs) {
    settings = stgs;
    return module.exports;
};

//rpass
var getDefaultRpass = module.exports.getDefaultRpass = function (encoding) {
    //init
    settings.defaultRpass = settings.defaultRpass || {};

    if (settings.defaultRpass[encoding]) {

    }
    else {
        var crypto = require('crypto');
        var sha1 = crypto.createHash('sha1');
        sha1.update(settings.rpass);

        settings.defaultRpass[encoding] = sha1.digest(encoding);
    }

    return settings.defaultRpass[encoding];
};

//handy shortcut for cryption functions
var encrypt = exports.encrypt = function (str, rpass) {
    return JsCrypt.AES.encrypt(str, rpass, { format:JsonFormatter }).toString();
}

var encryptAsObj = exports.encryptAsObj = function (str, rpass) {
    // use standard simple json obj to return the cyphered data
    return JsCrypt.AES.encrypt(str, rpass, { format:JsonFormatter }).toObject();
}

var isValidEncryptedObject = exports.isValidEncryptedObject = function (obj) {
    if (obj && Object.prototype.toString.call(obj) === "[object Object]" && obj.ct && obj.iv && obj.s) {
        return true;
    }

    return false;
}

var decrypt = exports.decrypt = function (encrypted, rpass) {
    //use utf8 as default
    return JsCrypt.enc.Utf8.stringify(JsCrypt.AES.decrypt(encrypted, rpass, {format:JsonFormatter}));
}

//module based key generator and authorization
exports.getRequestTicket = function (name) {
    var rpass = getDefaultRpass('base64');

    // calculate a token
    // time based token
    // var token = crypto.randomBytes(128).toString("base64");
    var token = (new Date()).getTime() + '+' + name;

    // simply use hex encoding
    return new Buffer(encrypt(token, rpass)).toString('hex');
}

exports.authTicket = function (ticket, name) {
    if (ticket) {
        //hex decode;
        ticket = new Buffer(ticket, 'hex').toString('utf8');

        //decrypt
        var rpass = getDefaultRpass('base64');
        var token = decrypt(ticket, rpass);

        //time + service name
        var regex = /(\d+)\+(.*)/i;
        var infos = regex.exec(token);

        if (infos && infos.length >= 3) {

            var timestamp = parseInt(infos[1]);
            if (isNaN(timestamp)) {
                return false;
            }

            var requestService = infos[2];

            if (
            //check timestamp
                Math.abs((new Date()).getTime() - timestamp) < 3600 * 1000
                    && requestService === name
                ) {

                return true;
            }
        }
    }
}
