{"ts":1359974407792,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1359975454395,"patch":[[{"diffs":[[1,"/**\n * app is designed to listen port 80 and handle the http protocal.\n */\n var root;\n var server;\n var domain = require('domain');\n var cluster = require('cluster);\n var settings = require('../cfg/settings');\n \n exports.runServer = function (rootDirectory) {\n        if (cluster.isMaster) {\n            //Fork workers.\n            var cpus = require('os').cpus().length;\n            for (var i = 0; i < cpus; i++) {\n                cluster.fork();    \n            }\n            \n            // Restart process after exiting.\n            cluster.on('exit', function (worker, code, signal) {\n                // Fork a new process after exiting. How about the child process failed to start?\n                var exitCode = worker.process.exitCode;\n                console.log('worker ' + worker.process.pid + ' died (' + exitCode + ') . restarting...');\n                cluster.fork();\n            });\n        } else {\n            // Get root path first.\n            root = rootDirectory;\n            \n            // Find all global app modules and build the onStart and onRequest array.\n            var onStarts = new Array();\n            var onRequests = new Array();\n            for (var key in settings.modules) {\n                var m = require(settings.modules[key]);\n                if(m.onStart) {\n                    onStarts.push(m.onStart);\n                }\n                if (m.onRequest) {\n                    onRequests.push(m.onRequest);\n                }\n            }\n            \n            // Perpare onRequest iterator.\n            var requestMoving = function (ctx, index) {\n                if (index < onRequests.length) {\n                    if (onRequests[index].length >= 2) {\n                        // Async process request if the callback parameter is set. The callback parameter is alwayse the second paramter.  \n                        on\n                    }\n                }    \n            }\n            \n        }\n     }"]],"start1":0,"start2":0,"length1":0,"length2":1956}]],"length":1956,"saved":false}
{"ts":1359975950470,"patch":[[{"diffs":[[0,"  on"],[-1,"\n                    }\n                }    \n            }\n            "],[1,"Requests[index](ctx, function(err) {\n                            requestMoving(ctx, index + 1);\n                        });\n                    } else {\n                        // Sync process the request without callback parameter.\n                        onRequests[index](ctx);\n                        requestMoving(ctx, index + 1);\n                    }\n                }    \n            };\n            \n            // Workers can share any TCP connection\n            // In this case its a HTTP server\n            server = require('http').createServer(function(request, response) {\n                // Create request domain and handler request domain error.\n                var rdomain = domain.create();\n                rdomain.on('error', function (err) {\n                    console.log(err.stack);\n                    if (request.url.indexOf('debug=nodejs') != -1) {\n                        response.end(err.stack);\n                    } else {\n                        response.writeHead(510, 'Internal Server Error');\n                        response.end();\n                    }\n                    this.dispose();\n                });\n            });"],[0,"\n   "]],"start1":1864,"start2":1864,"length1":79,"length2":1167}]],"length":3044,"saved":false}
{"ts":1359977005409,"patch":[[{"diffs":[[0,"    "],[-1,"});\n        }\n     }"],[1,"    \n                // Run http request in domain\n                rdomain.run(function () {\n                    var ctx = {\n                        request:request,\n                        response:response,\n                        rootDirectory:rootDirectory\n                    };\n                    \n                    requestMoving(ctx, 0);\n                });\n            });\n            \n            /* DEBUG */\n            server.on('connection', function(socket) {\n                console.log('connection accepted.');\n                console.log('worker id:' + cluster.worker.id);\n            });\n            \n            //Prepare onStart iterator.\n            var startMoving = function (index, callback) {\n                if (index < onStarts.length) {\n                    if (onStarts[index].length >= 2) {\n                        // Async process request if the callback parameter is set. The callback parameter is alwayse the second parameter.\n                        onStarts[index](server, function (err) {\n                            if (err) {\n                                callback.apply(this, arguments);    \n                            } else {\n                                startMoving(index + 1, callback);\n                            }\n                        });\n                    } else {\n                        // Sync process the request without callback parameter.\n                        var ret = onStarts[index](server);\n                        if (ret) {\n                            startMoving(index + 1, callback);\n                        } else {\n                            callback(true, 'Failed To Start Server: ' + index);\n                        }\n                    }\n                } else {\n                    callback();\n                }\n            };\n            \n            // Start all app.\n            startMoving(0, function(err) {\n                if (err) {\n                    console.log('Failed To Start Server');\n                } else {\n                    if (settings.port) {\n                        server.listen(settings.port);\n                    }\n                }\n                \n            });\n        }\n     };\n     \n     exports.setSettings = function (stgs) {\n         settings = stgs;\n         return exports;\n     };\n     \n     exports.getRootDirectory = function () {\n         return root;\n     };\n     \n     exports.getHttpServer = function () {\n        return server;    \n     };\n     \n     "]],"start1":3020,"start2":3020,"length1":24,"length2":2485}]],"length":5505,"saved":false}
{"contributors":[],"silentsave":false,"ts":1360044381768,"patch":[[{"diffs":[[0,"'cluster"],[1,"'"],[0,");\n var "]],"start1":155,"start2":155,"length1":16,"length2":17}]],"length":5506,"saved":false}
{"ts":1360044498470,"patch":[[{"diffs":[[0,"ng.\n            "],[1,"/*"],[0,"cluster.on('exit"]],"start1":523,"start2":523,"length1":32,"length2":34},{"diffs":[[0,"ster.fork();"],[1,"*/"],[0,"\n           "]],"start1":873,"start2":873,"length1":24,"length2":26}]],"length":5510,"saved":false}
{"ts":1360044513086,"patch":[[{"diffs":[[0,".fork();"],[-1,"*/"],[0,"\n       "]],"start1":877,"start2":877,"length1":18,"length2":16},{"diffs":[[0,"\n            });"],[1,"*/"],[0,"\n        } else "]],"start1":885,"start2":885,"length1":32,"length2":34}]],"length":5510,"saved":false}
{"ts":1360044543016,"patch":[[{"diffs":[[0,"        "],[-1,"/*"],[0,"cluster."]],"start1":531,"start2":531,"length1":18,"length2":16},{"diffs":[[0,"     });"],[-1,"*/"],[0,"\n       "]],"start1":891,"start2":891,"length1":18,"length2":16}]],"length":5506,"saved":false}
{"ts":1360045791442,"patch":[[{"diffs":[[0,"ngs.port"],[1,", settings.por"],[0,");\n     "]],"start1":5117,"start2":5117,"length1":16,"length2":30}]],"length":5520,"saved":false}
{"ts":1360045796180,"patch":[[{"diffs":[[0,"ettings."],[1,"i"],[0,"p"],[-1,"or"],[0,");\n     "]],"start1":5128,"start2":5128,"length1":19,"length2":18}]],"length":5519,"saved":false}
{"ts":1360045974308,"patch":[[{"diffs":[[0,"ngs.port) {\n"],[1,"                        console.log(settings.ip);\n"],[0,"            "]],"start1":5062,"start2":5062,"length1":24,"length2":74}]],"length":5569,"saved":false}
